<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs EFM32 USB Stack: release/EM_CMSIS_P1_4.0.0/usb/src/em_usbtimer.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_99634199317e4752b1934502e0d836c4.html">release</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_ef8fe3615cb8c81ea34985a2c039aa1a.html">EM_CMSIS_P1_4.0.0</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_d529fad7523b6d6416aa1a0e742e0db9.html">usb</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_a30f87d09d62889fdc20774a0697d5af.html">src</a>
  </div>
</div>
<div class="contents">
<h1>em_usbtimer.c</h1><a href="em__usbtimer_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************/</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;em_device.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#if defined( USB_PRESENT ) &amp;&amp; ( USB_COUNT == 1 )</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="em__usb_8h.html" title="USB protocol stack library API for EFM32.">em_usb.h</a>&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#if defined( USB_DEVICE ) || defined( USB_HOST )</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;em_cmu.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;em_timer.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="em__usbtypes_8h.html" title="USB protocol stack library, internal type definitions.">em_usbtypes.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="em__usbhal_8h.html" title="USB protocol stack library, low level USB peripheral access.">em_usbhal.h</a>&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"> *  Use one HW timer to serve n software milisecond timers.</span>
<a name="l00028"></a>00028 <span class="comment"> *  A timer is, when running, in a linked list of timers.</span>
<a name="l00029"></a>00029 <span class="comment"> *  A given timers timeout period is the acculmulated timeout</span>
<a name="l00030"></a>00030 <span class="comment"> *  of all timers preceeding it in the queue.</span>
<a name="l00031"></a>00031 <span class="comment"> *  This makes timer start (linked list insertion) computing intensive,</span>
<a name="l00032"></a>00032 <span class="comment"> *  but the checking of the queue at each tick very effective.</span>
<a name="l00033"></a>00033 <span class="comment"> *             ______          ______          ______</span>
<a name="l00034"></a>00034 <span class="comment"> *            |      |    ---&gt;|      |    ---&gt;|      |</span>
<a name="l00035"></a>00035 <span class="comment"> *   head --&gt; |      |   |    |      |   |    |      |</span>
<a name="l00036"></a>00036 <span class="comment"> *            |______|---     |______|---     |______|---/ NULL</span>
<a name="l00037"></a>00037 <span class="comment"> */</span>
<a name="l00038"></a>00038 
<a name="l00041"></a>00041 <span class="preprocessor">#ifndef USB_TIMER</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#define USB_TIMER USB_TIMER0</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="preprocessor">#if ( USB_TIMER == USB_TIMER0 ) &amp;&amp; ( TIMER_COUNT &gt;= 1 )</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER             TIMER0</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_CLK         cmuClock_TIMER0</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_IRQ         TIMER0_IRQn</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_IRQHandler  TIMER0_IRQHandler</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 <span class="preprocessor">#elif ( USB_TIMER == USB_TIMER1 ) &amp;&amp; ( TIMER_COUNT &gt;= 2 )</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER             TIMER1</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_CLK         cmuClock_TIMER1</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_IRQ         TIMER1_IRQn</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_IRQHandler  TIMER1_IRQHandler</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a>00057 <span class="preprocessor">#elif ( USB_TIMER == USB_TIMER2 ) &amp;&amp; ( TIMER_COUNT &gt;= 3 )</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER             TIMER2</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_CLK         cmuClock_TIMER2</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_IRQ         TIMER2_IRQn</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_IRQHandler  TIMER2_IRQHandler</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="preprocessor">#elif ( USB_TIMER == USB_TIMER3 ) &amp;&amp; ( TIMER_COUNT == 4 )</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER             TIMER3</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_CLK         cmuClock_TIMER3</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_IRQ         TIMER3_IRQn</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">  #define TIMER_IRQHandler  TIMER3_IRQHandler</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>
<a name="l00069"></a>00069 <span class="preprocessor">#else</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#error &quot;Illegal USB TIMER definition&quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span>
<a name="l00073"></a>00073 <span class="keyword">typedef</span> <span class="keyword">struct </span>_timer
<a name="l00074"></a>00074 {
<a name="l00075"></a>00075   uint32_t                  timeout;  <span class="comment">/* Delta value relative to prev. timer */</span>
<a name="l00076"></a>00076   <span class="keyword">struct </span>_timer             *next;
<a name="l00077"></a>00077   <a class="code" href="group__USB__COMMON.html#ga26fb3e3f2a565d58f81724e087fc15c6" title="USBTIMER callback function.">USBTIMER_Callback_TypeDef</a> callback;
<a name="l00078"></a>00078   <span class="keywordtype">bool</span>                      running;
<a name="l00079"></a>00079 } USBTIMER_Timer_TypeDef;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="preprocessor">#if ( NUM_QTIMERS &gt; 0 )</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="keyword">static</span> USBTIMER_Timer_TypeDef timers[ NUM_QTIMERS ];
<a name="l00083"></a>00083 <span class="keyword">static</span> USBTIMER_Timer_TypeDef *head = NULL;
<a name="l00084"></a>00084 <span class="preprocessor">#endif</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>
<a name="l00086"></a>00086 <span class="keyword">static</span> uint32_t ticksPrMs, ticksPr1us, ticksPr10us, ticksPr100us;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="preprocessor">#if ( NUM_QTIMERS &gt; 0 )</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>
<a name="l00090"></a>00090 <span class="keyword">static</span> <span class="keywordtype">void</span> TimerTick( <span class="keywordtype">void</span> );
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="keywordtype">void</span> TIMER_IRQHandler( <span class="keywordtype">void</span> )
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094   uint32_t flags;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   flags = TIMER_IntGet( TIMER );
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   <span class="keywordflow">if</span> ( flags &amp; TIMER_IF_CC0 )
<a name="l00099"></a>00099   {
<a name="l00100"></a>00100     TIMER_IntClear( TIMER, TIMER_IFC_CC0 );
<a name="l00101"></a>00101     TIMER_CompareSet( TIMER, 0, TIMER_CaptureGet( TIMER, 0 ) + ticksPrMs );
<a name="l00102"></a>00102     TimerTick();
<a name="l00103"></a>00103   }
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 <span class="preprocessor">#endif </span><span class="comment">/* ( NUM_QTIMERS &gt; 0 ) */</span>
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="keyword">static</span> <span class="keywordtype">void</span> DelayTicks( uint16_t ticks )
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109   uint16_t startTime;
<a name="l00110"></a>00110   <span class="keyword">volatile</span> uint16_t now;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="keywordflow">if</span> ( ticks )
<a name="l00113"></a>00113   {
<a name="l00114"></a>00114     startTime = TIMER_CounterGet( TIMER );
<a name="l00115"></a>00115     <span class="keywordflow">do</span>
<a name="l00116"></a>00116     {
<a name="l00117"></a>00117       now = TIMER_CounterGet(TIMER);
<a name="l00118"></a>00118     } <span class="keywordflow">while</span> ( (uint16_t)( now - startTime ) &lt; ticks );
<a name="l00119"></a>00119   }
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00127"></a>00127 <span class="comment">/***************************************************************************/</span>
<a name="l00135"></a><a class="code" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951">00135</a> <span class="keywordtype">void</span> <a class="code" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951" title="Active wait millisecond delay function.">USBTIMER_DelayMs</a>( uint32_t msec )
<a name="l00136"></a>00136 {
<a name="l00137"></a>00137   uint64_t totalTicks;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   totalTicks = (uint64_t)ticksPrMs * msec;
<a name="l00140"></a>00140   <span class="keywordflow">while</span> ( totalTicks &gt; 20000 )
<a name="l00141"></a>00141   {
<a name="l00142"></a>00142     DelayTicks( 20000 );
<a name="l00143"></a>00143     totalTicks -= 20000;
<a name="l00144"></a>00144   }
<a name="l00145"></a>00145   DelayTicks( (uint16_t)totalTicks );
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="comment">/***************************************************************************/</span>
<a name="l00156"></a><a class="code" href="group__USB__COMMON.html#gafef1ec052374683fb7f26c5d27645e2c">00156</a> <span class="keywordtype">void</span> <a class="code" href="group__USB__COMMON.html#gafef1ec052374683fb7f26c5d27645e2c" title="Active wait microsecond delay function.">USBTIMER_DelayUs</a>( uint32_t usec )
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158   uint64_t totalTicks;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   totalTicks = (uint64_t)ticksPr1us * usec;
<a name="l00161"></a>00161   <span class="keywordflow">if</span> ( totalTicks == 0 )
<a name="l00162"></a>00162   {
<a name="l00163"></a>00163     usec /= 10;
<a name="l00164"></a>00164     totalTicks = (uint64_t)ticksPr10us * usec;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     <span class="keywordflow">if</span> ( totalTicks == 0 )
<a name="l00167"></a>00167     {
<a name="l00168"></a>00168       usec /= 10;
<a name="l00169"></a>00169       totalTicks = (uint64_t)ticksPr100us * usec;
<a name="l00170"></a>00170     }
<a name="l00171"></a>00171   }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="keywordflow">while</span> ( totalTicks &gt; 60000 )
<a name="l00174"></a>00174   {
<a name="l00175"></a>00175     DelayTicks( 60000 );
<a name="l00176"></a>00176     totalTicks -= 60000;
<a name="l00177"></a>00177   }
<a name="l00178"></a>00178   DelayTicks( (uint16_t)totalTicks );
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="comment">/***************************************************************************/</span>
<a name="l00190"></a><a class="code" href="group__USB__COMMON.html#ga21c87b800d87fd731173dd4f48f23c28">00190</a> <span class="keywordtype">void</span> <a class="code" href="group__USB__COMMON.html#ga21c87b800d87fd731173dd4f48f23c28" title="Activate the hardware timer used to pace the 1 millisecond timer system.">USBTIMER_Init</a>( <span class="keywordtype">void</span> )
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192   uint32_t freq;
<a name="l00193"></a>00193   TIMER_Init_TypeDef timerInit     = TIMER_INIT_DEFAULT;
<a name="l00194"></a>00194   TIMER_InitCC_TypeDef timerCCInit = TIMER_INITCC_DEFAULT;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   freq = CMU_ClockFreqGet( cmuClock_HFPER );
<a name="l00197"></a>00197   ticksPrMs = ( freq + 500 ) / 1000;
<a name="l00198"></a>00198   ticksPr1us = ( freq + 500000 ) / 1000000;
<a name="l00199"></a>00199   ticksPr10us = ( freq + 50000 ) / 100000;
<a name="l00200"></a>00200   ticksPr100us = ( freq + 5000 ) / 10000;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202   timerCCInit.mode = timerCCModeCompare;
<a name="l00203"></a>00203   CMU_ClockEnable( TIMER_CLK, <span class="keyword">true</span> );
<a name="l00204"></a>00204   TIMER_TopSet( TIMER, 0xFFFF );
<a name="l00205"></a>00205   TIMER_InitCC( TIMER, 0, &amp;timerCCInit );
<a name="l00206"></a>00206   TIMER_Init( TIMER, &amp;timerInit );
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="preprocessor">#if ( NUM_QTIMERS &gt; 0 )</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span>  TIMER_IntClear( TIMER, 0xFFFFFFFF );
<a name="l00210"></a>00210   TIMER_IntEnable( TIMER, TIMER_IEN_CC0 );
<a name="l00211"></a>00211   TIMER_CompareSet( TIMER, 0, TIMER_CounterGet( TIMER ) + ticksPrMs );
<a name="l00212"></a>00212   NVIC_ClearPendingIRQ( TIMER_IRQ );
<a name="l00213"></a>00213   NVIC_EnableIRQ( TIMER_IRQ );
<a name="l00214"></a>00214 <span class="preprocessor">#endif </span><span class="comment">/* ( NUM_QTIMERS &gt; 0 ) */</span>
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="preprocessor">#if ( NUM_QTIMERS &gt; 0 ) || defined( DOXY_DOC_ONLY )</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span><span class="comment">/***************************************************************************/</span>
<a name="l00234"></a><a class="code" href="group__USB__COMMON.html#gac2a406f16d989b04c4fc5b37d5c10b45">00234</a> <span class="keywordtype">void</span> <a class="code" href="group__USB__COMMON.html#gac2a406f16d989b04c4fc5b37d5c10b45" title="Start a timer.">USBTIMER_Start</a>( uint32_t <span class="keywordtype">id</span>, uint32_t timeout,
<a name="l00235"></a>00235                      <a class="code" href="group__USB__COMMON.html#ga26fb3e3f2a565d58f81724e087fc15c6" title="USBTIMER callback function.">USBTIMER_Callback_TypeDef</a> callback )
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237   uint32_t accumulated;
<a name="l00238"></a>00238   USBTIMER_Timer_TypeDef *<span class="keyword">this</span>, **last;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240   INT_Disable();
<a name="l00241"></a>00241 
<a name="l00242"></a>00242   <span class="keywordflow">if</span> ( timers[ <span class="keywordtype">id</span> ].running )
<a name="l00243"></a>00243   {
<a name="l00244"></a>00244     <a class="code" href="group__USB__COMMON.html#gab73c922427cf0d509788a8063451703f" title="Stop a timer.">USBTIMER_Stop</a>( <span class="keywordtype">id</span> );
<a name="l00245"></a>00245   }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="keywordflow">if</span> ( timeout == 0 )
<a name="l00248"></a>00248   {
<a name="l00249"></a>00249     callback();
<a name="l00250"></a>00250     INT_Enable();
<a name="l00251"></a>00251     <span class="keywordflow">return</span>;
<a name="l00252"></a>00252   }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254   timers[ id ].running  = <span class="keyword">true</span>;
<a name="l00255"></a>00255   timers[ id ].callback = callback;
<a name="l00256"></a>00256   timers[ id ].next     = NULL;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   <span class="keywordflow">if</span> ( !head )                                        <span class="comment">/* Queue empty ? */</span>
<a name="l00259"></a>00259   {
<a name="l00260"></a>00260     timers[ id ].timeout  = timeout;
<a name="l00261"></a>00261     head = &amp;timers[ id ];
<a name="l00262"></a>00262   }
<a name="l00263"></a>00263   <span class="keywordflow">else</span>
<a name="l00264"></a>00264   {
<a name="l00265"></a>00265     <span class="keyword">this</span> = head;
<a name="l00266"></a>00266     last = &amp;head;
<a name="l00267"></a>00267     accumulated = 0;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269     <span class="comment">/* Do a sorted insert */</span>
<a name="l00270"></a>00270     <span class="keywordflow">while</span> ( <span class="keyword">this</span>  )
<a name="l00271"></a>00271     {
<a name="l00272"></a>00272       <span class="keywordflow">if</span> ( timeout &lt; accumulated + this-&gt;timeout )  <span class="comment">/* Insert before &quot;this&quot; ? */</span>
<a name="l00273"></a>00273       {
<a name="l00274"></a>00274         timers[ id ].timeout  = timeout - accumulated;
<a name="l00275"></a>00275         timers[ id ].next     = <span class="keyword">this</span>;
<a name="l00276"></a>00276         *last = &amp;timers[ id ];
<a name="l00277"></a>00277         this-&gt;timeout -= timers[ id ].timeout;        <span class="comment">/* Adjust timeout     */</span>
<a name="l00278"></a>00278         <span class="keywordflow">break</span>;
<a name="l00279"></a>00279       }
<a name="l00280"></a>00280       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( this-&gt;next == NULL )                  <span class="comment">/* At end of queue ?  */</span>
<a name="l00281"></a>00281       {
<a name="l00282"></a>00282         timers[ id ].timeout  = timeout - accumulated - this-&gt;timeout;
<a name="l00283"></a>00283         this-&gt;next = &amp;timers[ id ];
<a name="l00284"></a>00284         <span class="keywordflow">break</span>;
<a name="l00285"></a>00285       }
<a name="l00286"></a>00286       accumulated += this-&gt;timeout;
<a name="l00287"></a>00287       last = &amp;this-&gt;next;
<a name="l00288"></a>00288       <span class="keyword">this</span> = this-&gt;next;
<a name="l00289"></a>00289     }
<a name="l00290"></a>00290   }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   INT_Enable();
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="comment">/***************************************************************************/</span>
<a name="l00302"></a><a class="code" href="group__USB__COMMON.html#gab73c922427cf0d509788a8063451703f">00302</a> <span class="keywordtype">void</span> <a class="code" href="group__USB__COMMON.html#gab73c922427cf0d509788a8063451703f" title="Stop a timer.">USBTIMER_Stop</a>( uint32_t <span class="keywordtype">id</span> )
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304   USBTIMER_Timer_TypeDef *<span class="keyword">this</span>, **last;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   INT_Disable();
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="keywordflow">if</span> ( head )                                           <span class="comment">/* Queue empty ?    */</span>
<a name="l00309"></a>00309   {
<a name="l00310"></a>00310     <span class="keyword">this</span> = head;
<a name="l00311"></a>00311     last = &amp;head;
<a name="l00312"></a>00312     timers[ id ].running = <span class="keyword">false</span>;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     <span class="keywordflow">while</span> ( <span class="keyword">this</span>  )
<a name="l00315"></a>00315     {
<a name="l00316"></a>00316       <span class="keywordflow">if</span> ( <span class="keyword">this</span> == &amp;timers[ <span class="keywordtype">id</span> ] )                      <span class="comment">/* Correct timer ?  */</span>
<a name="l00317"></a>00317       {
<a name="l00318"></a>00318         <span class="keywordflow">if</span> ( this-&gt;next )
<a name="l00319"></a>00319         {
<a name="l00320"></a>00320           this-&gt;next-&gt;timeout += timers[ id ].timeout;  <span class="comment">/* Adjust timeout   */</span>
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322         *last = this-&gt;next;
<a name="l00323"></a>00323         <span class="keywordflow">break</span>;
<a name="l00324"></a>00324       }
<a name="l00325"></a>00325       last = &amp;this-&gt;next;
<a name="l00326"></a>00326       <span class="keyword">this</span> = this-&gt;next;
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328   }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   INT_Enable();
<a name="l00331"></a>00331 }
<a name="l00332"></a>00332 <span class="preprocessor">#endif </span><span class="comment">/* ( NUM_QTIMERS &gt; 0 ) */</span>
<a name="l00333"></a>00333 
<a name="l00336"></a>00336 <span class="preprocessor">#if ( NUM_QTIMERS &gt; 0 )</span>
<a name="l00337"></a>00337 <span class="preprocessor"></span>
<a name="l00339"></a>00339 <span class="keyword">static</span> <span class="keywordtype">void</span> TimerTick( <span class="keywordtype">void</span> )
<a name="l00340"></a>00340 {
<a name="l00341"></a>00341   <a class="code" href="group__USB__COMMON.html#ga26fb3e3f2a565d58f81724e087fc15c6" title="USBTIMER callback function.">USBTIMER_Callback_TypeDef</a> cb;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   INT_Disable();
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="keywordflow">if</span> ( head )
<a name="l00346"></a>00346   {
<a name="l00347"></a>00347     head-&gt;timeout--;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     <span class="keywordflow">while</span> ( head  )
<a name="l00350"></a>00350     {
<a name="l00351"></a>00351       <span class="keywordflow">if</span> ( head-&gt;timeout == 0 )
<a name="l00352"></a>00352       {
<a name="l00353"></a>00353         cb = head-&gt;callback;
<a name="l00354"></a>00354         head-&gt;running = <span class="keyword">false</span>;
<a name="l00355"></a>00355         head = head-&gt;next;
<a name="l00356"></a>00356         <span class="comment">/* The callback may place new items in the queue !!! */</span>
<a name="l00357"></a>00357         <span class="keywordflow">if</span> ( cb )
<a name="l00358"></a>00358         {
<a name="l00359"></a>00359           (cb)();
<a name="l00360"></a>00360         }
<a name="l00361"></a>00361         <span class="keywordflow">continue</span>; <span class="comment">/* There might be more than one timeout pr. tick */</span>
<a name="l00362"></a>00362       }
<a name="l00363"></a>00363       <span class="keywordflow">break</span>;
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365   }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   INT_Enable();
<a name="l00368"></a>00368 }
<a name="l00370"></a>00370 <span class="preprocessor">#endif </span><span class="comment">/* ( NUM_QTIMERS &gt; 0 ) */</span>
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="preprocessor">#endif </span><span class="comment">/* defined( USB_DEVICE ) || defined( USB_HOST ) */</span>
<a name="l00373"></a>00373 <span class="preprocessor">#endif </span><span class="comment">/* defined( USB_PRESENT ) &amp;&amp; ( USB_COUNT == 1 ) */</span>
</pre></div></div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu May 28 06:13:22 2015</small> for Silicon Labs EFM32 USB Stack by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
