<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Board Support Package: common/drivers/msdd.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c5ab7d5005c5f96afef39cd6ff9e2484.html">common</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_640347b79a58de25a4e6f9b018e8e1be.html">drivers</a>
  </div>
</div>
<div class="contents">
<h1>msdd.c</h1><a href="msdd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**************************************************************************/</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;em_usb.h&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;em_cmu.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;em_gpio.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;<a class="code" href="msdbot_8h.html" title="Definitions for the Bulk Only Transport protocol of USB Mass Storage devices.">msdbot.h</a>&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="msdscsi_8h.html" title="SCSI interface for Mass Storage Devices (MSD).">msdscsi.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="msdd_8h.html" title="Mass Storage class Device (MSD) driver.">msdd.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;msddmedia.h&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/**************************************************************************/</span>
<a name="l00058"></a>00058 <span class="comment">/*** Typedef&#39;s and defines. ***/</span>
<a name="l00059"></a>00059 <span class="preprocessor">#define MSD_DIR_DATA_OUT    0</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#define MSD_DIR_DATA_IN     1</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define MSD_MAX_BURST       32768U          </span><span class="comment">/* 32 * 1024 */</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">/**************************************************************************/</span>
<a name="l00066"></a>00066 <span class="keyword">typedef</span> <span class="keyword">enum</span>
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068   MSDD_IDLE                 = 0,
<a name="l00069"></a>00069   MSDD_WAITFOR_CBW          = 1,
<a name="l00070"></a>00070   MSDD_WAITFOR_RECOVERY     = 2,
<a name="l00071"></a>00071   MSDD_SEND_CSW             = 3,
<a name="l00072"></a>00072   MSDD_WAIT_FOR_INUNSTALLED = 4,
<a name="l00073"></a>00073   MSDD_STALL_IN             = 5,
<a name="l00074"></a>00074   MSDD_ACCESS_INDIRECT      = 6,
<a name="l00075"></a>00075   MSDD_WRITE_INDIRECT       = 7,
<a name="l00076"></a>00076   MSDD_DO_CMD_TASK          = 8,
<a name="l00077"></a>00077 } msdState_TypeDef;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">/*** Function prototypes. ***/</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keywordtype">int</span>            CbwCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00082"></a>00082 __STATIC_INLINE <span class="keywordtype">bool</span>  CswMeaningful(<span class="keywordtype">void</span>);
<a name="l00083"></a>00083 __STATIC_INLINE <span class="keywordtype">bool</span>  CswValid(<span class="keywordtype">void</span>);
<a name="l00084"></a>00084 __STATIC_INLINE <span class="keywordtype">void</span>  EnableNextCbw(<span class="keywordtype">void</span>);
<a name="l00085"></a>00085 <span class="keyword">static</span> <span class="keywordtype">void</span>           ProcessScsiCdb(<span class="keywordtype">void</span>);
<a name="l00086"></a>00086 __STATIC_INLINE <span class="keywordtype">void</span>  SendCsw(<span class="keywordtype">void</span>);
<a name="l00087"></a>00087 <span class="keyword">static</span> <span class="keywordtype">void</span>           UsbXferBotData(uint8_t *data, uint32_t len, USB_XferCompleteCb_TypeDef cb);
<a name="l00088"></a>00088 <span class="keyword">static</span> <span class="keywordtype">void</span>           XferBotData(uint32_t length);
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keywordtype">int</span>            XferBotDataCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00090"></a>00090 <span class="keyword">static</span> <span class="keywordtype">int</span>            XferBotDataIndirectCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">/*** Variables ***/</span>
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">/* Storage for one CBW */</span>
<a name="l00095"></a>00095 STATIC_UBUF(cbw, USB_FS_BULK_EP_MAXSIZE);
<a name="l00096"></a>00096 <span class="keyword">static</span> <a class="code" href="structMSDBOT__CBW__TypeDef.html" title="Bulk Only Transport (BOT) Command Block Wrapper (CBW) typedef.">MSDBOT_CBW_TypeDef</a> *pCbw = (<a class="code" href="structMSDBOT__CBW__TypeDef.html" title="Bulk Only Transport (BOT) Command Block Wrapper (CBW) typedef.">MSDBOT_CBW_TypeDef</a>*) &amp;cbw;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 EFM32_ALIGN(4)
<a name="l00099"></a>00099 <span class="comment">/* Storage for one CSW */</span>
<a name="l00100"></a>00100 static <a class="code" href="structMSDBOT__CSW__TypeDef.html" title="Bulk Only Transport (BOT) Command Status Wrapper (CSW) typedef.">MSDBOT_CSW_TypeDef</a> csw __attribute__ ((aligned(4)));
<a name="l00101"></a>00101 static <a class="code" href="structMSDBOT__CSW__TypeDef.html" title="Bulk Only Transport (BOT) Command Status Wrapper (CSW) typedef.">MSDBOT_CSW_TypeDef</a> *pCsw = &amp;csw;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 STATIC_UBUF(mediaBuffer, <a class="code" href="group__Msd.html#gae1bda16775ab83b9f08d2196aef40898" title="Intermediate media storage buffer size.">MEDIA_BUFSIZ</a>);  <span class="comment">/* Intermediate media storage buffer */</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 static <a class="code" href="structMSDD__CmdStatus__TypeDef.html" title="Status info for one BOT CBW -&amp;gt; Data I/O -&amp;gt; CSW cycle.">MSDD_CmdStatus_TypeDef</a> CmdStatus;
<a name="l00106"></a>00106 static <a class="code" href="structMSDD__CmdStatus__TypeDef.html" title="Status info for one BOT CBW -&amp;gt; Data I/O -&amp;gt; CSW cycle.">MSDD_CmdStatus_TypeDef</a> *pCmdStatus = &amp;CmdStatus;
<a name="l00107"></a>00107 static msdState_TypeDef       savedState; <span class="comment">/* MSD state machine state. */</span>
<a name="l00108"></a>00108 static <span class="keywordtype">int</span> ledPort;
<a name="l00109"></a>00109 static <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ledPin;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">/**************************************************************************/</span>
<a name="l00114"></a>00114 EFM32_ALIGN(4)
<a name="l00115"></a>00115 static const <a class="code" href="structMSDSCSI__InquiryData__TypeDef.html" title="SCSI Inquiry response data typedef.">MSDSCSI_InquiryData_TypeDef</a> InquiryData __attribute__ ((aligned(4))) =
<a name="l00116"></a>00116 {
<a name="l00117"></a>00117   { .PeripheralDeviceType = 0, .PeripheralQualifier = 0 }, <span class="comment">/* Block device  */</span>
<a name="l00118"></a>00118   { .Reserved1            = 0, .Removable           = 1 },
<a name="l00119"></a>00119 
<a name="l00120"></a>00120   .Version = 5,                                       <span class="comment">/* T10 SPC-3 compliant */</span>
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   { .ResponseDataFormat = 2,                          <span class="comment">/* T10 SPC-3 compliant reponse data */</span>
<a name="l00123"></a>00123     .HiSup = 0, .NormACA = 0, .Obsolete1 = 0 },
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   .AdditionalLength = 31,
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   { .Protect = 0, .Reserved2 = 0, .ThirdPartyCode = 0,
<a name="l00128"></a>00128     .Tpgs    = 0, .Acc       = 0, .Sccs           = 0 },
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   { .Addr16 = 0, .Obsolete2 = 0, .MChngr = 0, .MultiP = 0,
<a name="l00131"></a>00131     .Vs1    = 0, .EncServ   = 0, .BQue   = 0 },
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   { .Vs2  = 0, .CmdQue = 0, .Obsolete3 = 0, .Linked = 0,
<a name="l00134"></a>00134     .Sync = 0, .Wbus16 = 0, .Obsolete4 = 0 },
<a name="l00135"></a>00135 
<a name="l00136"></a>00136   .T10VendorId          = { <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span> },
<a name="l00137"></a>00137   .ProductId            = { <span class="charliteral">&#39;E&#39;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;e&#39;</span> },
<a name="l00138"></a>00138   .ProductRevisionLevel ={ <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;.&#39;</span>, <span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;0&#39;</span> }
<a name="l00139"></a>00139 };
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">/**************************************************************************/</span>
<a name="l00146"></a>00146 EFM32_ALIGN(4)
<a name="l00147"></a>00147 static const <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> NoSenseData __attribute__ ((aligned(4))) =
<a name="l00148"></a>00148 {
<a name="l00149"></a>00149   { .ResponseCode = 0x70, .Valid = 0 },
<a name="l00150"></a>00150   .Obsolete = 0,
<a name="l00151"></a>00151   { .SenseKey = 0, .Reserved =0, .Ili = 0, .Eom = 0, .FileMark = 0 },
<a name="l00152"></a>00152   .Information      = 0,
<a name="l00153"></a>00153   .AdditionalLength = 10,
<a name="l00154"></a>00154   .CmdSpecificInfo  = 0,
<a name="l00155"></a>00155   .Asc              = 0,
<a name="l00156"></a>00156   .Ascq             = 0,
<a name="l00157"></a>00157   .Fruc             = 0,
<a name="l00158"></a>00158   { .SenseKeySpecific1 = 0, .Sksv = 0 },
<a name="l00159"></a>00159   .SenseKeySpecific2 = 0,
<a name="l00160"></a>00160   .SenseKeySpecific3 = 0
<a name="l00161"></a>00161 };
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">/**************************************************************************/</span>
<a name="l00169"></a>00169 EFM32_ALIGN(4)
<a name="l00170"></a>00170 static const <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> IllegalSenseData __attribute__ ((aligned(4))) =
<a name="l00171"></a>00171 {
<a name="l00172"></a>00172   { .ResponseCode = 0x70, .Valid = 0 },
<a name="l00173"></a>00173   .Obsolete = 0,
<a name="l00174"></a>00174   { .SenseKey = 5,                          <span class="comment">/* SensKey = 5 =&gt; ILLEGAL REQUEST */</span>
<a name="l00175"></a>00175     .Reserved = 0, .Ili = 0, .Eom = 0, .FileMark = 0 },
<a name="l00176"></a>00176   .Information      = 0,
<a name="l00177"></a>00177   .AdditionalLength = 10,
<a name="l00178"></a>00178   .CmdSpecificInfo  = 0,
<a name="l00179"></a>00179   .Asc              = 0x24,    <span class="comment">/* Asc/Ascq = 0x24/0x00 =&gt; INVALID FIELD IN CDB*/</span>
<a name="l00180"></a>00180   .Ascq             = 0,
<a name="l00181"></a>00181   .Fruc             = 0,
<a name="l00182"></a>00182   { .SenseKeySpecific1 = 0, .Sksv  = 0 },
<a name="l00183"></a>00183   .SenseKeySpecific2 = 0,
<a name="l00184"></a>00184   .SenseKeySpecific3 = 0
<a name="l00185"></a>00185 };
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="keyword">static</span> <span class="keyword">volatile</span> msdState_TypeDef        msdState;     
<a name="l00188"></a>00188 <span class="keyword">static</span> <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> *pSenseData;  
<a name="l00192"></a>00192 <span class="comment">/**************************************************************************/</span>
<a name="l00202"></a><a class="code" href="group__Msd.html#ga6bab19f6afa0c63c3c735c9bea3b8242">00202</a> <span class="keywordtype">void</span> <a class="code" href="group__Msd.html#ga6bab19f6afa0c63c3c735c9bea3b8242" title="Initialize MSD device.">MSDD_Init</a>(<span class="keywordtype">int</span> activityLedPort, uint32_t activityLedPin)
<a name="l00203"></a>00203 {
<a name="l00204"></a>00204   <span class="keywordflow">if</span> ( ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>)           != <a class="code" href="group__Msd.html#gaeeee5bff632d8292bdf27234a2db1610" title="SCSI Read (10) CBD length.">SCSI_READ10_LEN</a>           ) ||
<a name="l00205"></a>00205        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>)          != <a class="code" href="group__Msd.html#ga412dd9e12c21fbd38201d7b8fb4ac25f" title="SCSI Write (10) CDB length.">SCSI_WRITE10_LEN</a>          ) ||
<a name="l00206"></a>00206        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__Verify10__TypeDef.html" title="SCSI Verify 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Verify10_TypeDef</a>)         != <a class="code" href="group__Msd.html#ga334a21e13b25d306613eb4b2b2f46360" title="SCSI Verify (10) CDB length.">SCSI_VERIFY10_LEN</a>         ) ||
<a name="l00207"></a>00207        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a>)     != <a class="code" href="group__Msd.html#gaabd4aaed3342eaa039c186b217f54340" title="SCSI Request Sense CDB length.">SCSI_REQUESTSENSE_LEN</a>     ) ||
<a name="l00208"></a>00208        ( <span class="keyword">sizeof</span>(InquiryData)                      != <a class="code" href="group__Msd.html#ga59d92155a959caa17dee09196cf59e7c" title="SCSI Inquiry response data length.">SCSI_INQUIRYDATA_LEN</a>      ) ||
<a name="l00209"></a>00209        ( <span class="keyword">sizeof</span>(NoSenseData)                      != <a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a> ) ||
<a name="l00210"></a>00210        ( <span class="keyword">sizeof</span>(IllegalSenseData)                 != <a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a> ) ||
<a name="l00211"></a>00211        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a>)     != <a class="code" href="group__Msd.html#ga32c98aaaced7b71e7a0271aea8f4d0e4" title="SCSI Read Capacity CDB length.">SCSI_READCAPACITY_LEN</a>     ) ||
<a name="l00212"></a>00212        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__ReadCapacityData__TypeDef.html" title="SCSI Read Capacity response data typedef.">MSDSCSI_ReadCapacityData_TypeDef</a>) != <a class="code" href="group__Msd.html#gab6ed4755185c4e6d8d0de6f8dd021e8c" title="SCSI Read Capacity response data length.">SCSI_READCAPACITYDATA_LEN</a> )    )
<a name="l00213"></a>00213   {
<a name="l00214"></a>00214     DEBUG_USB_API_PUTS(<span class="stringliteral">&quot;\nMSDD_Init(), typedef size error&quot;</span>);
<a name="l00215"></a>00215     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00216"></a>00216     <span class="keywordflow">return</span>;
<a name="l00217"></a>00217   }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="keywordflow">if</span> ( ( activityLedPort &gt;= gpioPortA ) &amp;&amp; ( activityLedPort &lt;= gpioPortF ) )
<a name="l00220"></a>00220     ledPort = activityLedPort;
<a name="l00221"></a>00221   <span class="keywordflow">else</span>
<a name="l00222"></a>00222     ledPort = -1;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   ledPin     = activityLedPin;
<a name="l00225"></a>00225   msdState   = MSDD_IDLE;
<a name="l00226"></a>00226   pSenseData = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;NoSenseData;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00229"></a>00229   {
<a name="l00230"></a>00230     CMU_ClockEnable(cmuClock_GPIO, <span class="keyword">true</span>);
<a name="l00231"></a>00231     GPIO_PinModeSet((GPIO_Port_TypeDef)ledPort, ledPin, gpioModePushPull, 0);
<a name="l00232"></a>00232   }
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="comment">/**************************************************************************/</span>
<a name="l00244"></a><a class="code" href="group__Msd.html#ga0dfd9473471d01231de7541cfd7f5ede">00244</a> <span class="keywordtype">bool</span> <a class="code" href="group__Msd.html#ga0dfd9473471d01231de7541cfd7f5ede" title="Serve the MSD state machine.">MSDD_Handler</a>(<span class="keywordtype">void</span>)
<a name="l00245"></a>00245 {
<a name="l00246"></a>00246   <span class="keyword">static</span> uint32_t len;        <span class="comment">/* Note: len is static ! */</span>
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="keywordflow">switch</span> (msdState)
<a name="l00249"></a>00249   {
<a name="l00250"></a>00250   <span class="keywordflow">case</span> MSDD_ACCESS_INDIRECT:
<a name="l00251"></a>00251     <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253       len = EFM32_MIN(pCmdStatus-&gt;xferLen, pCmdStatus-&gt;maxBurst);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255       msdState = MSDD_IDLE;
<a name="l00256"></a>00256       <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00257"></a>00257       {
<a name="l00258"></a>00258         MSDDMEDIA_Read(pCmdStatus, mediaBuffer, len / 512);
<a name="l00259"></a>00259       }
<a name="l00260"></a>00260       UsbXferBotData(mediaBuffer, len, XferBotDataIndirectCallback);
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262     <span class="keywordflow">else</span>
<a name="l00263"></a>00263     {
<a name="l00264"></a>00264       <span class="comment">/* We are done ! */</span>
<a name="l00265"></a>00265       msdState = savedState;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267       <span class="keywordflow">if</span> (msdState == MSDD_SEND_CSW)
<a name="l00268"></a>00268       {
<a name="l00269"></a>00269         SendCsw();
<a name="l00270"></a>00270         EnableNextCbw();
<a name="l00271"></a>00271         msdState = MSDD_WAITFOR_CBW;
<a name="l00272"></a>00272       }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msdState == MSDD_STALL_IN)
<a name="l00275"></a>00275       {
<a name="l00276"></a>00276         USBD_StallEp(MSD_BULK_IN);
<a name="l00277"></a>00277         msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00278"></a>00278       }
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280     <span class="keywordflow">break</span>;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282   <span class="keywordflow">case</span> MSDD_WRITE_INDIRECT:
<a name="l00283"></a>00283     MSDDMEDIA_Write(pCmdStatus, mediaBuffer, len / 512);
<a name="l00284"></a>00284     pCmdStatus-&gt;lba += len / 512;
<a name="l00285"></a>00285     msdState         = MSDD_ACCESS_INDIRECT;
<a name="l00286"></a>00286     <span class="keywordflow">break</span>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="keywordflow">case</span> MSDD_DO_CMD_TASK:
<a name="l00289"></a>00289     <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>[ 0 ] == <a class="code" href="group__Msd.html#ga732b33c6fded33c1e25db28a34f38315" title="SCSI Start Stop Unit command opcode.">SCSI_STARTSTOP_UNIT</a>)
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291       MSDDMEDIA_Flush();
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293     <span class="comment">/* else if ( .... )  Add more when needed. */</span>
<a name="l00294"></a>00294     SendCsw();
<a name="l00295"></a>00295     EnableNextCbw();
<a name="l00296"></a>00296     msdState = MSDD_WAITFOR_CBW;
<a name="l00297"></a>00297     <span class="keywordflow">break</span>;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="keywordflow">default</span>:
<a name="l00300"></a>00300     <span class="keywordflow">break</span>;
<a name="l00301"></a>00301   }
<a name="l00302"></a>00302   <span class="keywordflow">return</span> (msdState == MSDD_WAITFOR_CBW) || (msdState == MSDD_IDLE);
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="comment">/**************************************************************************/</span>
<a name="l00317"></a><a class="code" href="group__Msd.html#gafd14b40b8d009c6341c92a35b5e9ad42">00317</a> <span class="keywordtype">int</span> <a class="code" href="group__Msd.html#gafd14b40b8d009c6341c92a35b5e9ad42" title="Called whenever a USB setup command is received.">MSDD_SetupCmd</a>(<span class="keyword">const</span> USB_Setup_TypeDef *setup)
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319   <span class="keywordtype">int</span> retVal;
<a name="l00320"></a>00320   <span class="keyword">static</span> uint32_t tmp;
<a name="l00321"></a>00321 
<a name="l00322"></a>00322   retVal = USB_STATUS_REQ_UNHANDLED;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   <span class="comment">/* Check if it is MSD class command: &quot;Bulk-Only Mass Storage Reset&quot; */</span>
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="keywordflow">if</span> ( ( setup-&gt;Type      == USB_SETUP_TYPE_CLASS          ) &amp;&amp;
<a name="l00327"></a>00327        ( setup-&gt;Direction == USB_SETUP_DIR_OUT             ) &amp;&amp;
<a name="l00328"></a>00328        ( setup-&gt;Recipient == USB_SETUP_RECIPIENT_INTERFACE ) &amp;&amp;
<a name="l00329"></a>00329        ( setup-&gt;bRequest  == USB_MSD_BOTRESET              ) &amp;&amp;
<a name="l00330"></a>00330        ( setup-&gt;wValue    == 0                             ) &amp;&amp;
<a name="l00331"></a>00331        ( setup-&gt;wIndex    == MSD_INTERFACE_NO              ) &amp;&amp;
<a name="l00332"></a>00332        ( setup-&gt;wLength   == 0                             )    )
<a name="l00333"></a>00333   {
<a name="l00334"></a>00334     <span class="keywordflow">if</span> (msdState == MSDD_WAITFOR_RECOVERY)
<a name="l00335"></a>00335     {
<a name="l00336"></a>00336       msdState = MSDD_IDLE;
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338     retVal = USB_STATUS_OK;
<a name="l00339"></a>00339   }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 
<a name="l00342"></a>00342   <span class="comment">/* Check if it is MSD class command: &quot;Get Max LUN&quot; */</span>
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( setup-&gt;Type      == USB_SETUP_TYPE_CLASS          ) &amp;&amp;
<a name="l00345"></a>00345             ( setup-&gt;Direction == USB_SETUP_DIR_IN              ) &amp;&amp;
<a name="l00346"></a>00346             ( setup-&gt;Recipient == USB_SETUP_RECIPIENT_INTERFACE ) &amp;&amp;
<a name="l00347"></a>00347             ( setup-&gt;bRequest  == USB_MSD_GETMAXLUN             ) &amp;&amp;
<a name="l00348"></a>00348             ( setup-&gt;wValue    == 0                             ) &amp;&amp;
<a name="l00349"></a>00349             ( setup-&gt;wIndex    == MSD_INTERFACE_NO              ) &amp;&amp;
<a name="l00350"></a>00350             ( setup-&gt;wLength   == 1                             )    )
<a name="l00351"></a>00351   {
<a name="l00352"></a>00352     <span class="comment">/* Only one LUN (i.e. no support for multiple LUN&#39;s). Reply &quot;0&quot;. */</span>
<a name="l00353"></a>00353     tmp    = 0;
<a name="l00354"></a>00354     retVal = USBD_Write(0, (<span class="keywordtype">void</span>*) &amp;tmp, 1, NULL);
<a name="l00355"></a>00355   }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="comment">/* Check if it is a standard CLEAR_FEATURE endpoint command */</span>
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( setup-&gt;Type      == USB_SETUP_TYPE_STANDARD      ) &amp;&amp;
<a name="l00361"></a>00361             ( setup-&gt;Direction == USB_SETUP_DIR_OUT            ) &amp;&amp;
<a name="l00362"></a>00362             ( setup-&gt;Recipient == USB_SETUP_RECIPIENT_ENDPOINT ) &amp;&amp;
<a name="l00363"></a>00363             ( setup-&gt;bRequest  == CLEAR_FEATURE                ) &amp;&amp;
<a name="l00364"></a>00364             ( setup-&gt;wValue    == USB_FEATURE_ENDPOINT_HALT    ) &amp;&amp;
<a name="l00365"></a>00365             ( setup-&gt;wLength   == 0                            )    )
<a name="l00366"></a>00366   {
<a name="l00367"></a>00367     <span class="keywordflow">if</span> ( ( ( setup-&gt;wIndex &amp; 0xFF) == MSD_BULK_OUT ) ||
<a name="l00368"></a>00368          ( ( setup-&gt;wIndex &amp; 0xFF) == MSD_BULK_IN  )    )
<a name="l00369"></a>00369     {
<a name="l00370"></a>00370       retVal = USB_STATUS_OK;
<a name="l00371"></a>00371 
<a name="l00372"></a>00372       <span class="comment">/* Dont unstall ep&#39;s when waiting for reset recovery */</span>
<a name="l00373"></a>00373       <span class="keywordflow">if</span> (msdState != MSDD_WAITFOR_RECOVERY)
<a name="l00374"></a>00374       {
<a name="l00375"></a>00375         retVal = USBD_UnStallEp(setup-&gt;wIndex &amp; 0xFF);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377         <span class="keywordflow">if</span> ((setup-&gt;wIndex &amp; 0xFF) == MSD_BULK_IN)
<a name="l00378"></a>00378         {
<a name="l00379"></a>00379           <span class="keywordflow">if</span> (msdState == MSDD_WAIT_FOR_INUNSTALLED)
<a name="l00380"></a>00380           {
<a name="l00381"></a>00381             SendCsw();
<a name="l00382"></a>00382             EnableNextCbw();
<a name="l00383"></a>00383             msdState = MSDD_WAITFOR_CBW;
<a name="l00384"></a>00384           }
<a name="l00385"></a>00385         }
<a name="l00386"></a>00386         <span class="keywordflow">else</span>
<a name="l00387"></a>00387         {
<a name="l00388"></a>00388           EnableNextCbw();
<a name="l00389"></a>00389           msdState = MSDD_WAITFOR_CBW;
<a name="l00390"></a>00390         }
<a name="l00391"></a>00391       }
<a name="l00392"></a>00392     }
<a name="l00393"></a>00393   }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <span class="keywordflow">return</span> retVal;
<a name="l00396"></a>00396 }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 <span class="comment">/**************************************************************************/</span>
<a name="l00408"></a><a class="code" href="group__Msd.html#ga8ee87f447439d9642c706b68e9905e4a">00408</a> <span class="keywordtype">void</span> <a class="code" href="group__Msd.html#ga8ee87f447439d9642c706b68e9905e4a" title="Called whenever the USB device has changed its device state.">MSDD_StateChangeEvent</a>( USBD_State_TypeDef oldState,
<a name="l00409"></a>00409                             USBD_State_TypeDef newState )
<a name="l00410"></a>00410 {
<a name="l00411"></a>00411   <span class="keywordflow">if</span> (newState == USBD_STATE_CONFIGURED)
<a name="l00412"></a>00412   {
<a name="l00413"></a>00413     <span class="comment">/* We have been configured, start MSD functionality ! */</span>
<a name="l00414"></a>00414     EnableNextCbw();
<a name="l00415"></a>00415     msdState = MSDD_WAITFOR_CBW;
<a name="l00416"></a>00416   }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((oldState == USBD_STATE_CONFIGURED) &amp;&amp;
<a name="l00419"></a>00419            (newState != USBD_STATE_SUSPENDED))
<a name="l00420"></a>00420   {
<a name="l00421"></a>00421     <span class="comment">/* We have been de-configured */</span>
<a name="l00422"></a>00422     msdState = MSDD_IDLE;
<a name="l00423"></a>00423   }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newState == USBD_STATE_SUSPENDED)
<a name="l00426"></a>00426   {
<a name="l00427"></a>00427     <span class="comment">/* We have been suspended.                     */</span>
<a name="l00428"></a>00428     msdState = MSDD_IDLE;
<a name="l00429"></a>00429 
<a name="l00430"></a>00430     <span class="comment">/* Reduce current consumption to below 2.5 mA. */</span>
<a name="l00431"></a>00431   }
<a name="l00432"></a>00432 }
<a name="l00433"></a>00433 
<a name="l00436"></a>00436 <span class="comment">/**************************************************************************/</span>
<a name="l00453"></a>00453 <span class="keyword">static</span> <span class="keywordtype">int</span> CbwCallback(USB_Status_TypeDef status,
<a name="l00454"></a>00454                        uint32_t xferred, uint32_t remaining)
<a name="l00455"></a>00455 {
<a name="l00456"></a>00456   (void) remaining;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458   <span class="keywordflow">if</span> ( ( msdState == MSDD_WAITFOR_CBW ) &amp;&amp;
<a name="l00459"></a>00459        ( status   == USB_STATUS_OK    ) &amp;&amp;
<a name="l00460"></a>00460        ( xferred  == CBW_LEN          ) &amp;&amp;
<a name="l00461"></a>00461        ( CswValid()                   ) &amp;&amp;
<a name="l00462"></a>00462        ( CswMeaningful()              )    )
<a name="l00463"></a>00463   {
<a name="l00464"></a>00464     <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00465"></a>00465       GPIO_PinOutToggle((GPIO_Port_TypeDef)ledPort, ledPin);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     <span class="comment">/* Check the SCSI command descriptor block (CDB) */</span>
<a name="l00468"></a>00468     ProcessScsiCdb();
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (pCmdStatus-&gt;valid)
<a name="l00471"></a>00471       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDPASSED;
<a name="l00472"></a>00472     <span class="keywordflow">else</span>
<a name="l00473"></a>00473       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDFAILED;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475     pCsw-&gt;dCSWSignature   = CSW_SIGNATURE;
<a name="l00476"></a>00476     pCsw-&gt;dCSWTag         = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a51e2064e5f20133e5ce96bb3d79be263" title="The CBW tag.">dCBWTag</a>;
<a name="l00477"></a>00477     pCsw-&gt;dCSWDataResidue = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479     <span class="comment">/* Check the &quot;thirteen cases&quot; */</span>
<a name="l00480"></a>00480 
<a name="l00481"></a>00481     <span class="keywordflow">if</span> ((pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> != 0) &amp;&amp;
<a name="l00482"></a>00482         (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a> != pCmdStatus-&gt;direction))
<a name="l00483"></a>00483     {
<a name="l00484"></a>00484       <span class="comment">/* Handle cases 8 and 10 */</span>
<a name="l00485"></a>00485       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>)
<a name="l00488"></a>00488       {
<a name="l00489"></a>00489         <span class="comment">/* Host expects to receive data, case 8 */</span>
<a name="l00490"></a>00490         USBD_StallEp(MSD_BULK_IN);
<a name="l00491"></a>00491         msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00492"></a>00492       }
<a name="l00493"></a>00493       <span class="keywordflow">else</span>
<a name="l00494"></a>00494       {
<a name="l00495"></a>00495         <span class="comment">/* Host expects to send data, case 10 */</span>
<a name="l00496"></a>00496         USBD_StallEp(MSD_BULK_OUT);
<a name="l00497"></a>00497         SendCsw();
<a name="l00498"></a>00498         msdState = MSDD_IDLE;
<a name="l00499"></a>00499       }
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a> || (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == 0))
<a name="l00503"></a>00503     {
<a name="l00504"></a>00504       <span class="comment">/* SCSI IN commands or commands without data phase */</span>
<a name="l00505"></a>00505       <span class="comment">/* Handle cases 1-7 */</span>
<a name="l00506"></a>00506 
<a name="l00507"></a>00507       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == 0)
<a name="l00508"></a>00508       {
<a name="l00509"></a>00509         <span class="comment">/* Host expects no data, case 1, 2 or 3 */</span>
<a name="l00510"></a>00510         <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00511"></a>00511         {
<a name="l00512"></a>00512           <span class="comment">/* Device has data to transmit, case 2 &amp; 3 */</span>
<a name="l00513"></a>00513           pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00514"></a>00514         }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516         <span class="keywordflow">if</span> ((pCmdStatus-&gt;xferLen == 0) &amp;&amp;
<a name="l00517"></a>00517             (pCmdStatus-&gt;xferType == XFER_INDIRECT))
<a name="l00518"></a>00518         {
<a name="l00519"></a>00519           <span class="comment">/* Commands with no data phase which require timeconsuming  */</span>
<a name="l00520"></a>00520           <span class="comment">/* processing are executed in MSDD_Handler()                */</span>
<a name="l00521"></a>00521           msdState = MSDD_DO_CMD_TASK;
<a name="l00522"></a>00522         }
<a name="l00523"></a>00523         <span class="keywordflow">else</span>
<a name="l00524"></a>00524         {
<a name="l00525"></a>00525           SendCsw();
<a name="l00526"></a>00526           EnableNextCbw();
<a name="l00527"></a>00527           msdState = MSDD_WAITFOR_CBW;
<a name="l00528"></a>00528         }
<a name="l00529"></a>00529       }
<a name="l00530"></a>00530       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == pCmdStatus-&gt;xferLen)
<a name="l00531"></a>00531       {
<a name="l00532"></a>00532         <span class="comment">/* Host and device agree on transferlength, case 6 */</span>
<a name="l00533"></a>00533         <span class="comment">/* Send data to host */</span>
<a name="l00534"></a>00534         msdState = MSDD_SEND_CSW;
<a name="l00535"></a>00535         XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00536"></a>00536       }
<a name="l00537"></a>00537       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> &gt; pCmdStatus-&gt;xferLen)
<a name="l00538"></a>00538       {
<a name="l00539"></a>00539         <span class="comment">/* Host expects more data than device can provide, case 4 and 5 */</span>
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen &gt; 0)
<a name="l00542"></a>00542         {
<a name="l00543"></a>00543           <span class="comment">/* Device has data, case 5 */</span>
<a name="l00544"></a>00544           <span class="comment">/* Send data to host */</span>
<a name="l00545"></a>00545           msdState = MSDD_STALL_IN;
<a name="l00546"></a>00546           XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00547"></a>00547         }
<a name="l00548"></a>00548         <span class="keywordflow">else</span>
<a name="l00549"></a>00549         {
<a name="l00550"></a>00550           <span class="comment">/* Device has no data, case 4 */</span>
<a name="l00551"></a>00551           USBD_StallEp(MSD_BULK_IN);
<a name="l00552"></a>00552           msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554       }
<a name="l00555"></a>00555       <span class="keywordflow">else</span>
<a name="l00556"></a>00556       {
<a name="l00557"></a>00557         <span class="comment">/* Host expects less data than device will provide, case 7 */</span>
<a name="l00558"></a>00558         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00559"></a>00559         <span class="comment">/* Send data to host */</span>
<a name="l00560"></a>00560         msdState = MSDD_SEND_CSW;
<a name="l00561"></a>00561         XferBotData(pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>);
<a name="l00562"></a>00562       }
<a name="l00563"></a>00563     }
<a name="l00564"></a>00564 
<a name="l00565"></a>00565     <span class="keywordflow">else</span> <span class="comment">/* Host Direction is OUT and Host transferlength &gt; 0 */</span>
<a name="l00566"></a>00566     {
<a name="l00567"></a>00567       <span class="comment">/* SCSI OUT commands */</span>
<a name="l00568"></a>00568       <span class="comment">/* Handle cases 9, 11, 12 and 13 */</span>
<a name="l00569"></a>00569 
<a name="l00570"></a>00570       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == pCmdStatus-&gt;xferLen)
<a name="l00571"></a>00571       {
<a name="l00572"></a>00572         <span class="comment">/* Host and device agree on transferlength, case 12 */</span>
<a name="l00573"></a>00573 
<a name="l00574"></a>00574         <span class="comment">/* Read data from host */</span>
<a name="l00575"></a>00575         msdState = MSDD_SEND_CSW;
<a name="l00576"></a>00576         XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00577"></a>00577       }
<a name="l00578"></a>00578       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> &gt; pCmdStatus-&gt;xferLen)
<a name="l00579"></a>00579       {
<a name="l00580"></a>00580         <span class="comment">/* Host intend to send more data than device expects, case 9 &amp; 11 */</span>
<a name="l00581"></a>00581         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDFAILED;
<a name="l00582"></a>00582         USBD_StallEp(MSD_BULK_OUT);
<a name="l00583"></a>00583         SendCsw();
<a name="l00584"></a>00584         msdState = MSDD_IDLE;
<a name="l00585"></a>00585       }
<a name="l00586"></a>00586       <span class="keywordflow">else</span>
<a name="l00587"></a>00587       {
<a name="l00588"></a>00588         <span class="comment">/* Host has less data than device expects to receive, case 13 */</span>
<a name="l00589"></a>00589         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00590"></a>00590         USBD_StallEp(MSD_BULK_OUT);
<a name="l00591"></a>00591         SendCsw();
<a name="l00592"></a>00592         msdState = MSDD_IDLE;
<a name="l00593"></a>00593       }
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595     <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00596"></a>00596   }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   <span class="keywordflow">if</span> ((status == USB_STATUS_OK) &amp;&amp;
<a name="l00599"></a>00599       (USBD_GetUsbState() == USBD_STATE_CONFIGURED))
<a name="l00600"></a>00600   {
<a name="l00601"></a>00601     <span class="comment">/* Stall both Ep&#39;s and wait for reset recovery */</span>
<a name="l00602"></a>00602     USBD_StallEp(MSD_BULK_OUT);
<a name="l00603"></a>00603     USBD_StallEp(MSD_BULK_IN);
<a name="l00604"></a>00604     msdState = MSDD_WAITFOR_RECOVERY;
<a name="l00605"></a>00605   }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00608"></a>00608 }
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="comment">/**************************************************************************/</span>
<a name="l00615"></a>00615 __STATIC_INLINE <span class="keywordtype">bool</span> CswMeaningful(<span class="keywordtype">void</span>)
<a name="l00616"></a>00616 {
<a name="l00617"></a>00617   <span class="keywordflow">if</span> ( ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a1abbfdf14047d26d30fe8f66eeb1411e" title="Reserved, expect 0.">Reserved1</a> == 0 ) &amp;&amp;
<a name="l00618"></a>00618        ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a75f9c429399372fbe1fb70467210db20" title="Obsolete, expect 0.">Obsolete</a>  == 0 ) &amp;&amp;
<a name="l00619"></a>00619        ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#ad93f3797202c31f12d8dda26326b36be" title="Reserved, expect 0.">Reserved2</a> == 0 ) &amp;&amp;
<a name="l00620"></a>00620        ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#adab4dcae6200ccb3a2a5d0671aba3be5" title="Device Logical Unit Number.">Lun</a>       == 0 ) &amp;&amp;
<a name="l00621"></a>00621        ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a764d1ea8ecdae55613ff3ad79a8f3461" title="Reserved, expect 0.">Reserved3</a> == 0 )    )
<a name="l00622"></a>00622   {
<a name="l00623"></a>00623     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00624"></a>00624   }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="comment">/**************************************************************************/</span>
<a name="l00634"></a>00634 __STATIC_INLINE <span class="keywordtype">bool</span> CswValid(<span class="keywordtype">void</span>)
<a name="l00635"></a>00635 {
<a name="l00636"></a>00636   <span class="keywordflow">return</span> pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a713e73e9aba992ba6d97837ba39dec8c" title="The CBW signature (ascii USBC).">dCBWSignature</a> == CBW_SIGNATURE ? <span class="keyword">true</span> : <span class="keyword">false</span>; <span class="comment">/* Ascii USBC */</span>
<a name="l00637"></a>00637 }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 <span class="comment">/**************************************************************************/</span>
<a name="l00643"></a>00643 __STATIC_INLINE <span class="keywordtype">void</span> EnableNextCbw(<span class="keywordtype">void</span>)
<a name="l00644"></a>00644 {
<a name="l00645"></a>00645   USBD_Read(MSD_BULK_OUT, (<span class="keywordtype">void</span>*) &amp;cbw, USB_FS_BULK_EP_MAXSIZE, CbwCallback);
<a name="l00646"></a>00646 }
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 <span class="comment">/**************************************************************************/</span>
<a name="l00653"></a>00653 <span class="keyword">static</span> <span class="keywordtype">void</span> ProcessScsiCdb(<span class="keywordtype">void</span>)
<a name="l00654"></a>00654 {
<a name="l00655"></a>00655   <a class="code" href="structMSDSCSI__Inquiry__TypeDef.html" title="SCSI Inquiry Command Descriptor Block (CDB) typedef.">MSDSCSI_Inquiry_TypeDef</a>      *cbI;
<a name="l00656"></a>00656   <a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a> *cbRS;
<a name="l00657"></a>00657   <a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a> *cbRC;
<a name="l00658"></a>00658   <a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>       *cbR10;
<a name="l00659"></a>00659   <a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>      *cbW10;
<a name="l00660"></a>00660   <a class="code" href="structMSDSCSI__Verify10__TypeDef.html" title="SCSI Verify 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Verify10_TypeDef</a>     *cbV10;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662   EFM32_ALIGN(4)
<a name="l00663"></a>00663   static <a class="code" href="structMSDSCSI__ReadCapacityData__TypeDef.html" title="SCSI Read Capacity response data typedef.">MSDSCSI_ReadCapacityData_TypeDef</a> ReadCapData __attribute__ ((aligned(4)));
<a name="l00664"></a>00664 
<a name="l00665"></a>00665   pCmdStatus-&gt;valid    = false;
<a name="l00666"></a>00666   pCmdStatus-&gt;xferType = XFER_MEMORYMAPPED;
<a name="l00667"></a>00667   pCmdStatus-&gt;maxBurst = MSD_MAX_BURST;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   switch (pCbw-&gt;CBWCB[ 0 ])
<a name="l00670"></a>00670   {
<a name="l00671"></a>00671   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#gab4c8f5b2d1f25d97b00b9df156ccc283" title="SCSI Inquiry command opcode.">SCSI_INQUIRY</a>:
<a name="l00672"></a>00672     cbI = (<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html" title="SCSI Inquiry Command Descriptor Block (CDB) typedef.">MSDSCSI_Inquiry_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     if ((cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#af899eee2e39c656937846058b75ec6c0" title="Enable Vital Product data.">Evpd</a> == 0) &amp;&amp; (cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#a04ada094ef3e0a16ea93876216395476" title="Pagecode.">PageCode</a> == 0))
<a name="l00675"></a>00675     {
<a name="l00676"></a>00676       <span class="comment">/* Standard Inquiry data request */</span>
<a name="l00677"></a>00677       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00678"></a>00678       pCmdStatus-&gt;direction = MSD_DIR_DATA_IN;
<a name="l00679"></a>00679       pCmdStatus-&gt;pData     = (uint8_t*) &amp;InquiryData;
<a name="l00680"></a>00680       pCmdStatus-&gt;xferLen   = EFM32_MIN(<a class="code" href="group__Msd.html#ga59d92155a959caa17dee09196cf59e7c" title="SCSI Inquiry response data length.">SCSI_INQUIRYDATA_LEN</a>,
<a name="l00681"></a>00681                                         __REV16(cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#a425c76925763cc8e363882b9a16493e0" title="Number of inquiry data bytes requested.">AllocationLength</a>));
<a name="l00682"></a>00682     }
<a name="l00683"></a>00683     <span class="keywordflow">break</span>;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga10f4287430fb0b3832ef457bd413d709" title="SCSI Request Sense command opcode.">SCSI_REQUESTSENSE</a>:
<a name="l00686"></a>00686     cbRS = (<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00687"></a>00687 
<a name="l00688"></a>00688     if ((cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#ae2b17b045b6184a08d78553837a90de9" title="Descriptor format.">Desc</a> == 0) &amp;&amp; (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a8bb0ae69d8e75ed18fdb619b465d748f" title="Reserved, expect 0.">Reserved1</a> == 0) &amp;&amp;
<a name="l00689"></a>00689         (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a198e363c27bbe1a92976ff6aca143eb7" title="Reserved, expect 0.">Reserved2</a> == 0) &amp;&amp; (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a6c5abb63ad406f601ca9532c095fe2e5" title="Reserved, expect 0.">Reserved3</a> == 0))
<a name="l00690"></a>00690     {
<a name="l00691"></a>00691       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00692"></a>00692       pCmdStatus-&gt;direction = MSD_DIR_DATA_IN;
<a name="l00693"></a>00693       pCmdStatus-&gt;pData     = (uint8_t*) pSenseData;
<a name="l00694"></a>00694       pCmdStatus-&gt;xferLen   = EFM32_MIN(<a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a>,
<a name="l00695"></a>00695                                         cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#af731f84bb4dd977080536bc124573bc5" title="Number of sense data bytes requested.">AllocationLength</a>);
<a name="l00696"></a>00696       pSenseData = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;NoSenseData;
<a name="l00697"></a>00697     }
<a name="l00698"></a>00698     <span class="keywordflow">break</span>;
<a name="l00699"></a>00699 
<a name="l00700"></a>00700   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga5f964a9cdf8ee464d1250534d85b67be" title="SCSI Read Capacity command opcode.">SCSI_READCAPACITY</a>:
<a name="l00701"></a>00701     cbRC = (<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     if ((cbRC-&gt;<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html#a0c5c6644819e22145dddcebc72042fa0" title="Partial medium indicator.">Pmi</a> == 0) &amp;&amp; (cbRC-&gt;<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html#a68cd5734a4019cd89f9880c7ea74b95b" title="Logical Block (sector) Address.">Lba</a> == 0))
<a name="l00704"></a>00704     {
<a name="l00705"></a>00705       ReadCapData.LogicalBlockAddress = __REV(MSDDMEDIA_GetSectorCount() - 1);
<a name="l00706"></a>00706       ReadCapData.LogicalBlockLength  = __REV(512);
<a name="l00707"></a>00707 
<a name="l00708"></a>00708       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00709"></a>00709       pCmdStatus-&gt;direction = MSD_DIR_DATA_IN;
<a name="l00710"></a>00710       pCmdStatus-&gt;pData     = (uint8_t*) &amp;ReadCapData;
<a name="l00711"></a>00711       pCmdStatus-&gt;xferLen   = <a class="code" href="group__Msd.html#gab6ed4755185c4e6d8d0de6f8dd021e8c" title="SCSI Read Capacity response data length.">SCSI_READCAPACITYDATA_LEN</a>;
<a name="l00712"></a>00712     }
<a name="l00713"></a>00713     <span class="keywordflow">break</span>;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga4f9d424a949ee51924aa88f283afb085" title="SCSI Read (10) command opcode.">SCSI_READ10</a>:
<a name="l00716"></a>00716     cbR10 = (<a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     pCmdStatus-&gt;direction = MSD_DIR_DATA_IN;
<a name="l00719"></a>00719     pCmdStatus-&gt;valid     = MSDDMEDIA_CheckAccess(pCmdStatus,
<a name="l00720"></a>00720                                                   __REV(cbR10-&gt;<a class="code" href="structMSDSCSI__Read10__TypeDef.html#a0f7d380926a76054cfc9f1ba47e606b0" title="Logical Block (sector) Address.">Lba</a>),
<a name="l00721"></a>00721                                                   __REV16(cbR10-&gt;<a class="code" href="structMSDSCSI__Read10__TypeDef.html#ac761573476109ed41d9ae45932d3fcf4" title="Number of blocks (sectors) to transfer.">TransferLength</a>));
<a name="l00722"></a>00722     <span class="keywordflow">break</span>;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga4a9efd10e4c1670e2c3546f937e9cb34" title="SCSI Write (10) command opcode.">SCSI_WRITE10</a>:
<a name="l00725"></a>00725     cbW10 = (<a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727     pCmdStatus-&gt;direction = MSD_DIR_DATA_OUT;
<a name="l00728"></a>00728     pCmdStatus-&gt;valid     = MSDDMEDIA_CheckAccess(pCmdStatus,
<a name="l00729"></a>00729                                                   __REV(cbW10-&gt;<a class="code" href="structMSDSCSI__Write10__TypeDef.html#a8e61a32441fc28c57dbc04a9962d0386" title="Logical Block (sector) Address.">Lba</a>),
<a name="l00730"></a>00730                                                   __REV16(cbW10-&gt;<a class="code" href="structMSDSCSI__Write10__TypeDef.html#a5473a605c45f7cda62e548f54d7091dd" title="Number of blocks (sectors) to transfer.">TransferLength</a>));
<a name="l00731"></a>00731     <span class="keywordflow">break</span>;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga4f799250b498efb9dc2378a7a1baa302" title="SCSI Verify (10) command opcode.">SCSI_VERIFY10</a>:
<a name="l00734"></a>00734     cbV10 = (<a class="code" href="structMSDSCSI__Verify10__TypeDef.html" title="SCSI Verify 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Verify10_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     if ((cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#a4cf6da4c4a0443bff4e1b3b9d78ebc1d" title="Byte check bit.">BytChk</a>      == 0) &amp;&amp; (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#afe13ed477f355fdd34c3d10843bc31f5" title="Reserved, expect 0.">Reserved1</a> == 0) &amp;&amp;
<a name="l00737"></a>00737         (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#a3f9d0c3d3f6a0d4258f5f5e7649f0471" title="Disable Page Out.">Dpo</a>         == 0) &amp;&amp; (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#ae54d995272dc054a0e9fbbd81f3f068c" title="Verify Protect field.">VrProtect</a> == 0) &amp;&amp;
<a name="l00738"></a>00738         (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#a78e4e235d994c3abc8711f5c64f794ac" title="Group Number field.">GroupNumber</a> == 0) &amp;&amp; (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#a01e41e3686ae7f1dce001471cebabc1b" title="Reserved, expect 0.">Reserved2</a> == 0) &amp;&amp;
<a name="l00739"></a>00739         (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#adfe482cd9c3347df2e2bb5d4ac018890" title="Treat as a reserved field, expect 0.">Restricted</a>  == 0))
<a name="l00740"></a>00740     {
<a name="l00741"></a>00741       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00742"></a>00742       pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00743"></a>00743       pCmdStatus-&gt;xferLen   = 0;
<a name="l00744"></a>00744     }
<a name="l00745"></a>00745     <span class="keywordflow">break</span>;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#gac15197fa8bd507ec529006c64f8437eb" title="SCSI Test Unit Ready command opcode.">SCSI_TESTUNIT_READY</a>:
<a name="l00748"></a>00748     pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00749"></a>00749     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00750"></a>00750     pCmdStatus-&gt;xferLen   = 0;
<a name="l00751"></a>00751     <span class="keywordflow">break</span>;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga732b33c6fded33c1e25db28a34f38315" title="SCSI Start Stop Unit command opcode.">SCSI_STARTSTOP_UNIT</a>:
<a name="l00754"></a>00754     pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00755"></a>00755     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00756"></a>00756     pCmdStatus-&gt;xferLen   = 0;
<a name="l00757"></a>00757     pCmdStatus-&gt;xferType  = XFER_INDIRECT;
<a name="l00758"></a>00758     <span class="keywordflow">break</span>;
<a name="l00759"></a>00759   }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761   <span class="keywordflow">if</span> (!pCmdStatus-&gt;valid)
<a name="l00762"></a>00762   {
<a name="l00763"></a>00763     pCmdStatus-&gt;xferLen   = 0;
<a name="l00764"></a>00764     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00765"></a>00765     pSenseData            = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;IllegalSenseData;
<a name="l00766"></a>00766   }
<a name="l00767"></a>00767 }
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="comment">/**************************************************************************/</span>
<a name="l00773"></a>00773 __STATIC_INLINE <span class="keywordtype">void</span> SendCsw(<span class="keywordtype">void</span>)
<a name="l00774"></a>00774 {
<a name="l00775"></a>00775   <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00776"></a>00776     GPIO_PinOutToggle((GPIO_Port_TypeDef)ledPort, ledPin);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778   USBD_Write(MSD_BULK_IN, (<span class="keywordtype">void</span>*) &amp;csw, CSW_LEN, NULL);
<a name="l00779"></a>00779 }
<a name="l00780"></a>00780 
<a name="l00781"></a>00781 <span class="comment">/**************************************************************************/</span>
<a name="l00795"></a>00795 <span class="keyword">static</span> <span class="keywordtype">void</span> UsbXferBotData(uint8_t *data, uint32_t len,
<a name="l00796"></a>00796                            USB_XferCompleteCb_TypeDef cb)
<a name="l00797"></a>00797 {
<a name="l00798"></a>00798   <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00799"></a>00799   {
<a name="l00800"></a>00800     USBD_Write(MSD_BULK_IN, data, len, cb);
<a name="l00801"></a>00801   }
<a name="l00802"></a>00802   <span class="keywordflow">else</span>
<a name="l00803"></a>00803   {
<a name="l00804"></a>00804     USBD_Read(MSD_BULK_OUT, data, len, cb);
<a name="l00805"></a>00805   }
<a name="l00806"></a>00806 }
<a name="l00807"></a>00807 
<a name="l00808"></a>00808 <span class="comment">/**************************************************************************/</span>
<a name="l00816"></a>00816 <span class="keyword">static</span> <span class="keywordtype">void</span> XferBotData(uint32_t length)
<a name="l00817"></a>00817 {
<a name="l00818"></a>00818   pCmdStatus-&gt;xferLen   = length;
<a name="l00819"></a>00819   pCsw-&gt;dCSWDataResidue = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>;
<a name="l00820"></a>00820 
<a name="l00821"></a>00821   <span class="keywordflow">if</span> (pCmdStatus-&gt;xferType == XFER_INDIRECT)
<a name="l00822"></a>00822   {
<a name="l00823"></a>00823     <span class="comment">/* Access media in &quot;background&quot; polling loop, i.e. in MSDD_Handler() */</span>
<a name="l00824"></a>00824     savedState = msdState;
<a name="l00825"></a>00825     msdState   = MSDD_ACCESS_INDIRECT;
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827   <span class="keywordflow">else</span>
<a name="l00828"></a>00828   {
<a name="l00829"></a>00829     UsbXferBotData(pCmdStatus-&gt;pData,
<a name="l00830"></a>00830                    EFM32_MIN(length, pCmdStatus-&gt;maxBurst),
<a name="l00831"></a>00831                    XferBotDataCallback);
<a name="l00832"></a>00832   }
<a name="l00833"></a>00833 }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 <span class="comment">/**************************************************************************/</span>
<a name="l00854"></a>00854 <span class="keyword">static</span> <span class="keywordtype">int</span> XferBotDataCallback(USB_Status_TypeDef status,
<a name="l00855"></a>00855                                uint32_t xferred, uint32_t remaining)
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857   (void) status;
<a name="l00858"></a>00858   (void) remaining;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860   pCmdStatus-&gt;xferLen   -= xferred;
<a name="l00861"></a>00861   pCsw-&gt;dCSWDataResidue -= xferred;
<a name="l00862"></a>00862 
<a name="l00863"></a>00863   <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00864"></a>00864   {
<a name="l00865"></a>00865     pCmdStatus-&gt;pData += xferred;
<a name="l00866"></a>00866     UsbXferBotData(pCmdStatus-&gt;pData,
<a name="l00867"></a>00867                    EFM32_MIN(pCmdStatus-&gt;xferLen, pCmdStatus-&gt;maxBurst),
<a name="l00868"></a>00868                    XferBotDataCallback);
<a name="l00869"></a>00869   }
<a name="l00870"></a>00870   <span class="keywordflow">else</span>
<a name="l00871"></a>00871   {
<a name="l00872"></a>00872     <span class="keywordflow">if</span> (msdState == MSDD_SEND_CSW)
<a name="l00873"></a>00873     {
<a name="l00874"></a>00874       SendCsw();
<a name="l00875"></a>00875       EnableNextCbw();
<a name="l00876"></a>00876       msdState = MSDD_WAITFOR_CBW;
<a name="l00877"></a>00877     }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msdState == MSDD_STALL_IN)
<a name="l00880"></a>00880     {
<a name="l00881"></a>00881       USBD_StallEp(MSD_BULK_IN);
<a name="l00882"></a>00882       msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00883"></a>00883     }
<a name="l00884"></a>00884   }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="comment">/**************************************************************************/</span>
<a name="l00906"></a>00906 <span class="keyword">static</span> <span class="keywordtype">int</span> XferBotDataIndirectCallback(USB_Status_TypeDef status,
<a name="l00907"></a>00907                                        uint32_t xferred, uint32_t remaining)
<a name="l00908"></a>00908 {
<a name="l00909"></a>00909   (void) status;
<a name="l00910"></a>00910   (void) remaining;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912   pCmdStatus-&gt;xferLen   -= xferred;
<a name="l00913"></a>00913   pCsw-&gt;dCSWDataResidue -= xferred;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915   <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00916"></a>00916   {
<a name="l00917"></a>00917     pCmdStatus-&gt;lba += xferred / 512;
<a name="l00918"></a>00918     msdState         = MSDD_ACCESS_INDIRECT;
<a name="l00919"></a>00919   }
<a name="l00920"></a>00920   <span class="keywordflow">else</span>
<a name="l00921"></a>00921   {
<a name="l00922"></a>00922     msdState = MSDD_WRITE_INDIRECT;
<a name="l00923"></a>00923   }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00926"></a>00926 }
<a name="l00927"></a>00927 
</pre></div></div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Fri May 29 11:29:21 2015</small> for Board Support Package by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
